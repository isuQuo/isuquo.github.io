<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Crackme challenge #4 & #5 | My blog</title><meta name=keywords content><meta name=description content="Today we&rsquo;ll be looking at two ringzer0 Reverse Engineering challenges called &ldquo;Windows x86 reversing is cool&rdquo; and &ldquo;Windows API for the win&rdquo;. Both challenges are worth 3 and 4 points respectively.
The goal of the challenges is to find the flag hidden within.
Windows x86 reversing is cool When executing the application, it asks for a key. Typing in &ldquo;1234&rdquo; yields a &ldquo;Wrong Key!&rdquo; string:
Static analysis: Analysing the exe in IDA, we can see the key function is found at address 0x40139B."><meta name=author content><link rel=canonical href=https://isuquo.github.io/posts/crackme-4-5/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://isuquo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://isuquo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://isuquo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://isuquo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://isuquo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Crackme challenge #4 & #5"><meta property="og:description" content="Today we&rsquo;ll be looking at two ringzer0 Reverse Engineering challenges called &ldquo;Windows x86 reversing is cool&rdquo; and &ldquo;Windows API for the win&rdquo;. Both challenges are worth 3 and 4 points respectively.
The goal of the challenges is to find the flag hidden within.
Windows x86 reversing is cool When executing the application, it asks for a key. Typing in &ldquo;1234&rdquo; yields a &ldquo;Wrong Key!&rdquo; string:
Static analysis: Analysing the exe in IDA, we can see the key function is found at address 0x40139B."><meta property="og:type" content="article"><meta property="og:url" content="https://isuquo.github.io/posts/crackme-4-5/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Crackme challenge #4 & #5"><meta name=twitter:description content="Today we&rsquo;ll be looking at two ringzer0 Reverse Engineering challenges called &ldquo;Windows x86 reversing is cool&rdquo; and &ldquo;Windows API for the win&rdquo;. Both challenges are worth 3 and 4 points respectively.
The goal of the challenges is to find the flag hidden within.
Windows x86 reversing is cool When executing the application, it asks for a key. Typing in &ldquo;1234&rdquo; yields a &ldquo;Wrong Key!&rdquo; string:
Static analysis: Analysing the exe in IDA, we can see the key function is found at address 0x40139B."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://isuquo.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Crackme challenge #4 \u0026 #5","item":"https://isuquo.github.io/posts/crackme-4-5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Crackme challenge #4 \u0026 #5","name":"Crackme challenge #4 \u0026 #5","description":"Today we\u0026rsquo;ll be looking at two ringzer0 Reverse Engineering challenges called \u0026ldquo;Windows x86 reversing is cool\u0026rdquo; and \u0026ldquo;Windows API for the win\u0026rdquo;. Both challenges are worth 3 and 4 points respectively.\nThe goal of the challenges is to find the flag hidden within.\nWindows x86 reversing is cool When executing the application, it asks for a key. Typing in \u0026ldquo;1234\u0026rdquo; yields a \u0026ldquo;Wrong Key!\u0026rdquo; string:\nStatic analysis: Analysing the exe in IDA, we can see the key function is found at address 0x40139B.","keywords":[],"articleBody":"Today we’ll be looking at two ringzer0 Reverse Engineering challenges called “Windows x86 reversing is cool” and “Windows API for the win”. Both challenges are worth 3 and 4 points respectively.\nThe goal of the challenges is to find the flag hidden within.\nWindows x86 reversing is cool When executing the application, it asks for a key. Typing in “1234” yields a “Wrong Key!” string:\nStatic analysis: Analysing the exe in IDA, we can see the key function is found at address 0x40139B. We can also see our “Wrong Key!” string in here.\nAs above, it looks like our key will need to be at a length of 6 otherwise “Wrong Key!” is returned.\nIf our key is 6 characters long, we run into another function that takes our input and XORs the input with 0xFFFFFFD3. At the end before the jump, we can see a compare against our key and the key it is expecting.\nWe can use Ollydbg to debug this function and find out what it is expecting.\nDynamic analysis: We can find all referenced strings and quickly jump to the address our “Wrong Key!” string is found at.\nWe set a breakpoint at the beginning of the function in the previous function. We punch in our key as “123456”:\nBeforehand, EBP-1C was set to 0, so both EAX and EDX registers are set to 0. The first byte of our key is placed into DL. The EDX register is XOR’d with 0xFFFFFFD3 and returns 0xFFFFFFE2. DL is then placed into the first byte of our key, essentially replacing “1” (0x31) with 0xE2.\nWe can see in the next screenshot that a byte from the address found at EBP+EAX-423 (0x28FAF5) is moved into the AL register, where it is then compared against our DL register.\nLooping through this function, we find that it is comparing against the following values, 0x97, 0xE0, 0xEB, 0xA0, 0xB8, 0xEL, respectively.\nI have created a small Python script to simulate the function to find out the exact combination of characters we need to input to hopefully crack the program:\nimport string\rkey = 0xFFFFFFD3\rfor s in string.printable:\rresult = int(hex(ord(s)), 16) ^ int(hex(key), 16)\rdl = str(hex(result))[-2:]\rif dl == '97':\rprint('97', s)\rif dl == 'e0':\rprint('e0', s)\rif dl == 'eb':\rprint('eb', s)\rif dl == 'a0':\rprint('a0', s)\rif dl == 'b8':\rprint('b8', s)\rif dl == 'e1':\rprint('e1', s) After running the script, we find the correct combination is “D38sk2”, let’s try that:\nHoorah!\nWindows API for the win This challenge is much like the other one, it asks for a password and if wrong, returns “Wrong password!”.\nStatic analysis: Nothing valuable is found in the strings other than the “Wrong password!” we’ve already come across, again, much like the previous challenge.\nIf we double click on the “Wrong password!” string, we are taken to what looks like the password function we’re after, located at address 0x4014C9.\nThe following screenshot takes our password and runs through a bunch of functions that don’t appear to do much. After each function call, the EAX register is reset back to the return value of GlobalAlloc. At the end of the function, a call to strlen is made, comparing our password to a length of 6 characters.\nAmongst the function calls is a call to IsDebuggerPresent, but it does not matter as the return value is not used for anything. This is most likely a ploy to distract the reverser.\nIf our password is 6 characters long, we need to run through a second function that needs a little attention to determine what it is doing.\nStarting from the top, the first byte of our password is moved into the DL register. var_1C was set to the return value of GlobalAlloc, and that is moved into EAX. A byte from EAX is moved into AL and EAX and EDX are XOR’d against each other. At this point, we don’t know what EDX is set to. AL is then moved into the first byte of our password.\nThe same trend continues for each byte in our password. At the end of the function, we can see a call to strcmp. Let’s see if we can find out what the program is expecting by stepping through the above function.\nDynamic analysis: We can find all referenced strings and quickly jump to the function where our “Wrong password!” string is found.\nAfter we step through the call to scanf, we enter in our password as “123456”. As mentioned above from our IDA analysis, the first byte of our password is moved into DL. Stepping through the function, we can see that 0x08 is our mystery byte that is moved into AL. EAX and EDX are XOR’d against each other, and AL is moved into the first byte of our password.\nIn summary:\nTake first byte of password, put into dl Move 08 into al XOR eax, edx Move al into first byte of password For each consecutive byte of our password, C8 18 28 B8 E8 are moved into AL at step 2. For step 4, we can observe that 0x3B is moved into the first byte of our password.\nAt the end of the function before the call to strcmp, we can see the outcome of each byte of our password:\nAs these are not printable characters, if we were to create a script, how would be know what to be looking for? If we copy and paste them into Notepad, it is a little better:\nHowever, it would be quite difficult to create a script as we also need to know what the EDX register is set to for step 3. Going back through the instructions, I found EDX is set by a call to strlen. We simply need to find a better way.\nIf you take a look at the screenshot where we can see our non-printable characters the program has calculated, in the instructions, we can see the address where the non-printable characters are located at is loaded into EAX and then moved onto the stack. The same is done for our password (after step 4). They obviously don’t match.\nIf we continue stepping, we get to the instruction that jumps us to the “Wrong password!” area. If we alter the zero flag to trick the program into thinking our passwords matched, we come across to another instruction that takes the password and loads it into EAX at address 0x401626.\nWhat if we changed the instruction to instead load the address of the password that the program is actually looking for? As with a couple of screenshots up at address 0x40160D, this address is located at EBP-23.\nAfter we step over the modified instruction, let’s see what happens when we execute the rest of the program:\n","wordCount":"1136","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://isuquo.github.io/posts/crackme-4-5/"},"publisher":{"@type":"Organization","name":"My blog","logo":{"@type":"ImageObject","url":"https://isuquo.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://isuquo.github.io accesskey=h title="My blog (Alt + H)">My blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Crackme challenge #4 & #5</h1><div class=post-meta></div></header><div class=post-content><p>Today we&rsquo;ll be looking at two ringzer0 Reverse Engineering challenges called &ldquo;Windows x86 reversing is cool&rdquo; and &ldquo;Windows API for the win&rdquo;. Both challenges are worth 3 and 4 points respectively.</p><p>The goal of the challenges is to find the flag hidden within.</p><h1 id=windows-x86-reversing-is-cool>Windows x86 reversing is cool<a hidden class=anchor aria-hidden=true href=#windows-x86-reversing-is-cool>#</a></h1><p>When executing the application, it asks for a key. Typing in &ldquo;1234&rdquo; yields a &ldquo;Wrong Key!&rdquo; string:</p><p><img loading=lazy src=images/1.PNG alt></p><h2 id=static-analysis>Static analysis:<a hidden class=anchor aria-hidden=true href=#static-analysis>#</a></h2><p>Analysing the exe in IDA, we can see the key function is found at address 0x40139B. We can also see our &ldquo;Wrong Key!&rdquo; string in here.</p><p><img loading=lazy src=images/2.PNG alt></p><p>As above, it looks like our key will need to be at a length of 6 otherwise &ldquo;Wrong Key!&rdquo; is returned.</p><p><img loading=lazy src=images/3.PNG alt></p><p>If our key is 6 characters long, we run into another function that takes our input and XORs the input with 0xFFFFFFD3. At the end before the jump, we can see a compare against our key and the key it is expecting.</p><p>We can use Ollydbg to debug this function and find out what it is expecting.</p><h2 id=dynamic-analysis>Dynamic analysis:<a hidden class=anchor aria-hidden=true href=#dynamic-analysis>#</a></h2><p>We can find all referenced strings and quickly jump to the address our &ldquo;Wrong Key!&rdquo; string is found at.</p><p>We set a breakpoint at the beginning of the function in the previous function. We punch in our key as &ldquo;123456&rdquo;:</p><p><img loading=lazy src=images/4.PNG alt></p><p>Beforehand, EBP-1C was set to 0, so both EAX and EDX registers are set to 0. The first byte of our key is placed into DL. The EDX register is XOR&rsquo;d with 0xFFFFFFD3 and returns 0xFFFFFFE2. DL is then placed into the first byte of our key, essentially replacing &ldquo;1&rdquo; (0x31) with 0xE2.</p><p>We can see in the next screenshot that a byte from the address found at EBP+EAX-423 (0x28FAF5) is moved into the AL register, where it is then compared against our DL register.</p><p><img loading=lazy src=images/5.PNG alt></p><p>Looping through this function, we find that it is comparing against the following values, 0x97, 0xE0, 0xEB, 0xA0, 0xB8, 0xEL, respectively.</p><p>I have created a small Python script to simulate the function to find out the exact combination of characters we need to input to hopefully crack the program:</p><pre tabindex=0><code>import string

key = 0xFFFFFFD3

for s in string.printable:
 result = int(hex(ord(s)), 16) ^ int(hex(key), 16)
 dl = str(hex(result))[-2:]
 if dl == &#39;97&#39;:
  print(&#39;97&#39;, s)
 if dl == &#39;e0&#39;:
  print(&#39;e0&#39;, s)
 if dl == &#39;eb&#39;:
  print(&#39;eb&#39;, s)
 if dl == &#39;a0&#39;:
  print(&#39;a0&#39;, s)
 if dl == &#39;b8&#39;:
  print(&#39;b8&#39;, s)
 if dl == &#39;e1&#39;:
  print(&#39;e1&#39;, s)
</code></pre><p>After running the script, we find the correct combination is &ldquo;D38sk2&rdquo;, let&rsquo;s try that:</p><p><img loading=lazy src=images/6.PNG alt></p><p>Hoorah!</p><h1 id=windows-api-for-the-win>Windows API for the win<a hidden class=anchor aria-hidden=true href=#windows-api-for-the-win>#</a></h1><p>This challenge is much like the other one, it asks for a password and if wrong, returns &ldquo;Wrong password!&rdquo;.</p><h2 id=static-analysis-1>Static analysis:<a hidden class=anchor aria-hidden=true href=#static-analysis-1>#</a></h2><p>Nothing valuable is found in the strings other than the &ldquo;Wrong password!&rdquo; we&rsquo;ve already come across, again, much like the previous challenge.</p><p>If we double click on the &ldquo;Wrong password!&rdquo; string, we are taken to what looks like the password function we&rsquo;re after, located at address 0x4014C9.</p><p>The following screenshot takes our password and runs through a bunch of functions that don&rsquo;t appear to do much. After each function call, the EAX register is reset back to the return value of GlobalAlloc. At the end of the function, a call to strlen is made, comparing our password to a length of 6 characters.</p><p>Amongst the function calls is a call to IsDebuggerPresent, but it does not matter as the return value is not used for anything. This is most likely a ploy to distract the reverser.</p><p><img loading=lazy src=images/7.PNG alt></p><p>If our password is 6 characters long, we need to run through a second function that needs a little attention to determine what it is doing.</p><p><img loading=lazy src=images/8.PNG alt></p><p>Starting from the top, the first byte of our password is moved into the DL register. var_1C was set to the return value of GlobalAlloc, and that is moved into EAX. A byte from EAX is moved into AL and EAX and EDX are XOR&rsquo;d against each other. At this point, we don&rsquo;t know what EDX is set to. AL is then moved into the first byte of our password.</p><p>The same trend continues for each byte in our password. At the end of the function, we can see a call to strcmp. Let&rsquo;s see if we can find out what the program is expecting by stepping through the above function.</p><h2 id=dynamic-analysis-1>Dynamic analysis:<a hidden class=anchor aria-hidden=true href=#dynamic-analysis-1>#</a></h2><p>We can find all referenced strings and quickly jump to the function where our &ldquo;Wrong password!&rdquo; string is found.</p><p>After we step through the call to scanf, we enter in our password as &ldquo;123456&rdquo;. As mentioned above from our IDA analysis, the first byte of our password is moved into DL. Stepping through the function, we can see that 0x08 is our mystery byte that is moved into AL. EAX and EDX are XOR&rsquo;d against each other, and AL is moved into the first byte of our password.</p><p>In summary:</p><ol><li>Take first byte of password, put into dl</li><li>Move 08 into al</li><li>XOR eax, edx</li><li>Move al into first byte of password</li></ol><p>For each consecutive byte of our password, C8 18 28 B8 E8 are moved into AL at step 2. For step 4, we can observe that 0x3B is moved into the first byte of our password.</p><p>At the end of the function before the call to strcmp, we can see the outcome of each byte of our password:</p><p><img loading=lazy src=images/9.PNG alt></p><p>As these are not printable characters, if we were to create a script, how would be know what to be looking for? If we copy and paste them into Notepad, it is a little better:</p><p><img loading=lazy src=images/10.PNG alt></p><p>However, it would be quite difficult to create a script as we also need to know what the EDX register is set to for step 3. Going back through the instructions, I found EDX is set by a call to strlen. We simply need to find a better way.</p><p>If you take a look at the screenshot where we can see our non-printable characters the program has calculated, in the instructions, we can see the address where the non-printable characters are located at is loaded into EAX and then moved onto the stack. The same is done for our password (after step 4). They obviously don&rsquo;t match.</p><p>If we continue stepping, we get to the instruction that jumps us to the &ldquo;Wrong password!&rdquo; area. If we alter the zero flag to trick the program into thinking our passwords matched, we come across to another instruction that takes the password and loads it into EAX at address 0x401626.</p><p>What if we changed the instruction to instead load the address of the password that the program is actually looking for? As with a couple of screenshots up at address 0x40160D, this address is located at EBP-23.</p><p><img loading=lazy src=images/11.PNG alt></p><p>After we step over the modified instruction, let&rsquo;s see what happens when we execute the rest of the program:</p><p><img loading=lazy src=images/12.PNG alt></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>