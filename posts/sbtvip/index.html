<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SBTVIP CTF Challenges | My blog</title><meta name=keywords content><meta name=description content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><meta name=author content="map[hidefooter:true name:Reece Burke]"><link rel=canonical href=https://isuquo.github.io/posts/sbtvip/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://isuquo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://isuquo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://isuquo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://isuquo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://isuquo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://isuquo.github.io/posts/sbtvip/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://isuquo.github.io/posts/sbtvip/"><meta property="og:site_name" content="My blog"><meta property="og:title" content="SBTVIP CTF Challenges"><meta property="og:description" content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-29T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SBTVIP CTF Challenges"><meta name=twitter:description content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://isuquo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SBTVIP CTF Challenges","item":"https://isuquo.github.io/posts/sbtvip/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SBTVIP CTF Challenges","name":"SBTVIP CTF Challenges","description":"Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.\nAs the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!\n","keywords":[],"articleBody":"Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.\nAs the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!\nNetwork Analysis - Sneaky Transmission - 50 pts Is this a DoS attack? Or could this be … a photo!?\nWhen downloading the attached file for this challenge, we receive a sneaky_transmission.pcapng file. Viewing this file in Wireshark yields a packet capture full of ICMP packets.\nAs with all packet captures, we need to know what we’re dealing with and how the protocol works in order to ascertain what the high level goal of the capture is.\nGenerally when viewing ICMP packet captures, we need to bring our attention to a few things. First, we take note of the length of packet. They are all a length of 98 bytes. If it were anomalous, we could deem it as suspicious. Speaking of anomalous, we turn our attention to the TTL (time to live). Notice anything? All request packets have a different TTL set. This could be an indication of ICMP data exfiltration, or ICMP tunnelling.\nWe can begin to inspect the payload data of the request packets to see if we can make out any data being sent over the network. We can use the filter “icmp.type == 8” to only display request packets. When scrolling through each packet, we see part of the data section contains the same bytes:\nAs we scroll through each packet, we note the changing bytes. For the first few packets, it doesn’t look like much, until we get further down to frame no. 13. With a sharp eye, you might notice the following sequence of bytes:\nWhat do the highlighted bytes spell? JFIF! (without the exclamation mark). JFIF is the magic number for a JPEG image. The description of the challenge also confirms for us that the data being sent in the payload is a JPEG image. Next we need to extract the data.\nAt the time of my attempt at this challenge, I missed one important detail about the packets. The above highlighted bytes correpsond to the TTL value. Meaning the JPEG image was hidden in the TTL field, which would’ve made for easier extraction.\nAdmittedly, I did not extract the data using Wireshark nor using normal means via scripting. I used the Scapy Python module to exract the data but since I could not find a sure-fire method of extracting the exact bytes I wanted, so instead I implemented a method called Monkey Patching.\nAs mentioned, we will be using the Scapy Python module, a very popular packet manipulation tool.\nOur goal is to extract each byte at a specific offset of the payload data.\nAs you can see with the above, the only data from the payload we can print is the fixed data. It does not change.\nUsing the hexdump method Scapy provides, we can print out a hexdump of the payload data, exactly how it is displayed in Wireshark. The problem with this output is that it’s type is NoneType. It doesn’t output as a string. If this were the case, I could extract the specific bytes I needed using string slicing.\nThe only fix I managed for this was to edit the hexdump method provided by the Scapy library.\nLocated in the utls.py file, we can copy and paste the hexdump method into our own Python script:\nfrom scapy.all import *\rpkts = rdpcap(\"sneaky_transmission.pcapng\")\rdef hexdump(x, dump=False):\r\"\"\"Build a tcpdump like hexadecimal view\r:param x: a Packet\r:param dump: define if the result must be printed or returned in a variable\r:returns: a String only when dump=True\r\"\"\"\r# EDIT: create an empty list to append our bytes to\rsneaky_bytes = []\rs = \"\"\rx = bytes_encode(x)\rx_len = len(x)\ri = 0\rwhile i \u003c x_len:\rs += \"%04x \" % i\rfor j in range(16):\rif i + j \u003c x_len:\rs += \"%02X \" % orb(x[i + j])\r# EDIT: we only want to extract specific bytes\rif i == 0 and j == 8:\r# EDIT: append those bytes to our list\rsneaky_bytes.append(orb(x[i + j]))\relse:\rs += \" \"\rs += \" %s\\n\" % sane_color(x[i:i + 16])\ri += 16\r# remove trailing \\n\rs = s[:-1] if s.endswith(\"\\n\") else s\rif dump:\rreturn s\relse:\r# EDIT: create a new jpeg file and append our bytes to the file\rwith open('sneaky.jpg', 'ab') as fout:\rfout.write(bytearray(sneaky_bytes))\r#print(s) I have created comments with “EDIT: \" prepended to them to indicate which lines I have added.\nIf we execute this script, the specific bytes are extracted and appended to a JPEG file. If we open the JPG file after execution, our flag is revealed!\nPassword Cracking - Jumbled - 50 pts I've found a hash of the password for the domain controller.\r01F3273F68195C29A1A2365BE7AD2B1AAD469A73\rI've also found this note:\rCompany Password Policy:\r1 hex digit prepended\r1 hex digit appended\rFirst letter capitalised\rAn '@' appended to the end\rLeetspeak (a =\u003e 4, b =\u003e 6, e =\u003e 3, g =\u003e 9, i =\u003e 1, o =\u003e 0, s =\u003e 5, t =\u003e 7, z =\u003e 2) [Capital letters not included]\rExample: rockme =\u003e fR0ckm37@\rCan you crack the hash using rockyou.txt?\rThe flag is HilltopCTF{password}\rThis challenge was meant to be cracked using John The Ripper, however, I did not think to use it and instead began writing a Python script to brute force the hash.\nIn order to compute hashes and compare it to the one provided in the description of the challenge, we first need to determine what type of hash it is. Using Hash Analyzer, we can see it is a SHA1 hash.\nOverall, we need to derive a password in the format of \u003c@_sign\u003e.\nWe do this by first looping through the rockyou.txt file (HUGE file by the way, 14 million lines long), capitilize the first letter, substitute applicable letters for their leet counterparts (remember Python strings are immutable), prepend and append a hex digit to the output, and append an @ sign to the end of the final string.\nLastly, compute the hash of the final string and compare it with the one provided in the description of the challenge.\nI ran into an error when looping through the rockyou.txt file with regards to the encoding. The encoding of the file is supposedly UTF-8, but there are characters littered within that do not translate very well. I have used the codecs Python library to loop through each line and if any encoding errors are encountered, ignore them.\nRunning the following Python script takes ~1 hour to derive the correct hash and therefore provide us with thr flag to complete the challenge:\nimport string\rimport hashlib\rimport codecs\rleetspeak = {\r'a': '4',\r'b': '6',\r'e': '3',\r'g': '9',\r'i': '1',\r'o': '0',\r's': '5',\r't': '7',\r'z': '2'\r}\rcounter=0\rwith codecs.open('rockyou.txt', 'r', encoding='utf8', errors='ignore') as fin:\rfor word in fin:\rprint(counter, word)\rsample_text = word\rupper_text = sample_text[0].upper()\rupper_text += sample_text[1:]\rfor s in upper_text:\rif s.lower():\rfor k, v in leetspeak.items():\rif k==s:\rupper_text = upper_text.replace(s, v)\rnew_text = \"\".join(upper_text.split())\rfor first_hex_digit in string.hexdigits:\rfor last_hex_digit in string.hexdigits:\rhex_text = f\"{first_hex_digit}{new_text}{last_hex_digit}@\"\rhash = '01F3273F68195C29A1A2365BE7AD2B1AAD469A73'\tsha = hashlib.sha1(hex_text.encode('utf-8')).hexdigest()\rif sha.upper() == hash.upper():\rprint(f\"FOUND MATCH: {hex_text}\")\rwith open('jumbled_flag.txt', 'w') as fout:\rfout.write(f\"{hex_text}\")\rd = input()\rcounter+=1 Forensics - Repair Shop - 50 pts We got this file but the transmission might have corrupted it. Maybe our main suspect has tampered with the file. Help us to recover the file and the information we need!\nThe file provided to us for this challenge is named ‘unfixed’ and does not have an extension. If we examine the file in a hex editor, we can see the first few bytes are the following:\n‰PIG \u001a ��� IHDR��\u0003á��\u0003µ\b\u0006���\u0001¦ä\u0007��_zTXtRaw profile type exif��\nPIG is not a valid magic number, but the IHDR chunk indicates this is a PNG file. We can find the PNG file structure documentation here: http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html\nPIG should be corrected to PNG. If we run pngcheck in our Kali Linux VM, we get the following:\npngcheck unfixed unfixed illegal (unless recently approved) unknown, public chunk IPAD ERROR: unfixed\nUsing our hex editor, we can search for all instances of IPAD:\nThere are 172 instances of invalid IPAD chunk types! If we refer back to the PNG specification, we take note of the critical chunks a PNG must contain (or not). “A valid PNG image must contain an IHDR chunk, one or more IDAT chunks, and an IEND chunk.”\nOur unfixed file has an IHDR chunk, and… What’s this? An IEND chunk should note the end of a PNG file, howevever, I noticed something at the end of the file in the hex editor:\nIs this the flag we’re looking for? I have highlighted the interesting parts. We can see a PK text here. Consulting the magic numbers list, PK denotes the header of a ZIP file. Let’s try and open the unfixed file as an archive!\nYou might be asking why I’m revealing the flag to you. Well, if we copy and paste this into a base 64 decoder, it yields hilltopMSG{keep_looking}, which definitely is not our flag. Oh well, let’s keep looking.\nGoing back to our hex editor, we can see the text sEND just before the PK header. We can correct this to IEND.\nWe cannot have an image with a ZIP file appended to it, so we can remove all bytes after the IEND.\nOkay, that’s PNG, IHDR, IEND, so the only thing that is left is the IDAT chunks. As stated in the specification, there can be multiple of them. So if we search and replace all occurrences of IPAD to IDAT, we can open the fixed image and reveal our flag.\nForensics - Floppy Offset - 25 pts When we seized an old laptop and floppy disks, we identified an odd one. The forensic image didn’t match with the original. We can assume that there was some tampering. Also, the label on the floppy disk makes no sense to us. Can you recover the hidden information in the floppy disk?\nThere are three files included in this challenge, floppydisc.png, forensic.img, and original.img.\nWe’ll focus on the png file first, as I wanted to find out what the picture meant.\nGoogling for “rscds book 52 fnc” yields a YouTube video which I found funny. I don’t think it has much to do with the overall flag.\nIf we compute a hash for both the forensic and original images, we see a difference. If we use a hex compare utility to see which bytes are different, we see the following:\nIf we copy and paste this into a base 64 decoder, our flag is revealed.\nGeneral Knowledge - Twin - 25 pts Find the only pair of identical lines.\nSounds easy? Well, you’ve only got 88000 lines across 4400 files to compare.\nThe flag format is HilltopCTF{}.\nWell then, I’m sure a simple Python script should be able to loop through each line within all files and check if we have already looped through a specific line:\nimport os\rimport base64\rseen = set()\rfor root, dirs, files in os.walk(\"Twin\", topdown=False):\rfor name in files:\rwith open(f\"Twin\\\\{name}\", 'r') as fin:\rfor line in fin:\rline_lower = line.rstrip().lower()\rif line_lower in seen:\rprint(line)\rprint(base64.b64decode(line))\relse:\rseen.add(line_lower) Once it finds a duplicate line, it decodes it from base 64 to reveal something that is not a flag. Parts of the text have patterns, so maybe we need to decode it further. If we input the text into a ROT-13 decoder, our flag is revealed.\n","wordCount":"2021","inLanguage":"en","datePublished":"2020-02-29T00:00:00Z","dateModified":"2020-02-29T00:00:00Z","author":{"@type":"Person","name":{"hidefooter":true,"name":"Reece Burke"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://isuquo.github.io/posts/sbtvip/"},"publisher":{"@type":"Organization","name":"My blog","logo":{"@type":"ImageObject","url":"https://isuquo.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://isuquo.github.io/ accesskey=h title="My blog (Alt + H)">My blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SBTVIP CTF Challenges</h1><div class=post-meta><span title='2020-02-29 00:00:00 +0000 UTC'>February 29, 2020</span>&nbsp;·&nbsp;map[hidefooter:true name:Reece Burke]</div></header><div class=post-content><p>Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.</p><p>As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit <a href=https://sbtvip.ctfd.io/challenges>https://sbtvip.ctfd.io/challenges</a>, make an account and get going!</p><h1 id=network-analysis---sneaky-transmission---50-pts>Network Analysis - Sneaky Transmission - 50 pts<a hidden class=anchor aria-hidden=true href=#network-analysis---sneaky-transmission---50-pts>#</a></h1><blockquote><p>Is this a DoS attack? Or could this be &mldr; a photo!?</p></blockquote><p>When downloading the attached file for this challenge, we receive a sneaky_transmission.pcapng file. Viewing this file in Wireshark yields a packet capture full of ICMP packets.</p><p>As with all packet captures, we need to know what we&rsquo;re dealing with and how the protocol works in order to ascertain what the high level goal of the capture is.</p><p><img loading=lazy src=/posts/sbtvip/images/1.PNG></p><p>Generally when viewing ICMP packet captures, we need to bring our attention to a few things. First, we take note of the length of packet. They are all a length of 98 bytes. If it were anomalous, we could deem it as suspicious. Speaking of anomalous, we turn our attention to the TTL (time to live). Notice anything? All request packets have a different TTL set. This could be an indication of ICMP data exfiltration, or ICMP tunnelling.</p><p>We can begin to inspect the payload data of the request packets to see if we can make out any data being sent over the network. We can use the filter &ldquo;icmp.type == 8&rdquo; to only display request packets. When scrolling through each packet, we see part of the data section contains the same bytes:</p><p><img loading=lazy src=/posts/sbtvip/images/2.PNG></p><p>As we scroll through each packet, we note the changing bytes. For the first few packets, it doesn&rsquo;t look like much, until we get further down to frame no. 13. With a sharp eye, you might notice the following sequence of bytes:</p><p><img loading=lazy src=/posts/sbtvip/images/3.PNG></p><p><img loading=lazy src=/posts/sbtvip/images/4.PNG></p><p><img loading=lazy src=/posts/sbtvip/images/5.PNG></p><p><img loading=lazy src=/posts/sbtvip/images/6.PNG></p><p>What do the highlighted bytes spell? JFIF! (without the exclamation mark). JFIF is the magic number for a JPEG image. The description of the challenge also confirms for us that the data being sent in the payload is a JPEG image. Next we need to extract the data.</p><p>At the time of my attempt at this challenge, I missed one important detail about the packets. The above highlighted bytes correpsond to the TTL value. Meaning the JPEG image was hidden in the TTL field, which would&rsquo;ve made for easier extraction.</p><p>Admittedly, I did not extract the data using Wireshark nor using normal means via scripting. I used the Scapy Python module to exract the data but since I could not find a sure-fire method of extracting the exact bytes I wanted, so instead I implemented a method called Monkey Patching.</p><p>As mentioned, we will be using the Scapy Python module, a very popular packet manipulation tool.</p><p>Our goal is to extract each byte at a specific offset of the payload data.</p><p>As you can see with the above, the only data from the payload we can print is the fixed data. It does not change.</p><p>Using the hexdump method Scapy provides, we can print out a hexdump of the payload data, exactly how it is displayed in Wireshark. The problem with this output is that it&rsquo;s type is NoneType. It doesn&rsquo;t output as a string. If this were the case, I could extract the specific bytes I needed using string slicing.</p><p>The only fix I managed for this was to edit the hexdump method provided by the Scapy library.</p><p>Located in the utls.py file, we can copy and paste the hexdump method into our own Python script:</p><pre tabindex=0><code>from scapy.all import *
 
pkts = rdpcap(&#34;sneaky_transmission.pcapng&#34;)

def hexdump(x, dump=False):
    &#34;&#34;&#34;Build a tcpdump like hexadecimal view

    :param x: a Packet
    :param dump: define if the result must be printed or returned in a variable
    :returns: a String only when dump=True
    &#34;&#34;&#34;
    # EDIT: create an empty list to append our bytes to
    sneaky_bytes = []
    s = &#34;&#34;
    x = bytes_encode(x)
    x_len = len(x)
    i = 0
    while i &lt; x_len:
        s += &#34;%04x  &#34; % i
        for j in range(16):
            if i + j &lt; x_len:
                s += &#34;%02X &#34; % orb(x[i + j])
                # EDIT: we only want to extract specific bytes
                if i == 0 and j == 8:
                    # EDIT: append those bytes to our list
                    sneaky_bytes.append(orb(x[i + j]))
            else:
                s += &#34;   &#34;
        s += &#34; %s\n&#34; % sane_color(x[i:i + 16])
        i += 16
    # remove trailing \n
    s = s[:-1] if s.endswith(&#34;\n&#34;) else s
    if dump:
        return s
    else:
        # EDIT: create a new jpeg file and append our bytes to the file
        with open(&#39;sneaky.jpg&#39;, &#39;ab&#39;) as fout:
            fout.write(bytearray(sneaky_bytes))
        #print(s)
</code></pre><p>I have created comments with &ldquo;EDIT: " prepended to them to indicate which lines I have added.</p><p>If we execute this script, the specific bytes are extracted and appended to a JPEG file. If we open the JPG file after execution, our flag is revealed!</p><h1 id=password-cracking---jumbled---50-pts>Password Cracking - Jumbled - 50 pts<a hidden class=anchor aria-hidden=true href=#password-cracking---jumbled---50-pts>#</a></h1><blockquote></blockquote><pre><code>I've found a hash of the password for the domain controller.
01F3273F68195C29A1A2365BE7AD2B1AAD469A73
I've also found this note:
Company Password Policy:
1 hex digit prepended
1 hex digit appended
First letter capitalised
An '@' appended to the end
Leetspeak (a =&gt; 4, b =&gt; 6, e =&gt; 3, g =&gt; 9, i =&gt; 1, o =&gt; 0, s =&gt; 5, t =&gt; 7, z =&gt; 2) [Capital letters not included]
Example: rockme =&gt; fR0ckm37@

Can you crack the hash using rockyou.txt?

The flag is HilltopCTF{password}
</code></pre><p>This challenge was meant to be cracked using John The Ripper, however, I did not think to use it and instead began writing a Python script to brute force the hash.</p><p>In order to compute hashes and compare it to the one provided in the description of the challenge, we first need to determine what type of hash it is. Using Hash Analyzer, we can see it is a SHA1 hash.</p><p>Overall, we need to derive a password in the format of &lt;hex_digit> &lt;first_letter_capitalized> &lt;lowercase_leetspeak> &lt;hex_digit> &lt;@_sign>.</p><p>We do this by first looping through the rockyou.txt file (HUGE file by the way, 14 million lines long), capitilize the first letter, substitute applicable letters for their leet counterparts (remember Python strings are immutable), prepend and append a hex digit to the output, and append an @ sign to the end of the final string.</p><p>Lastly, compute the hash of the final string and compare it with the one provided in the description of the challenge.</p><p>I ran into an error when looping through the rockyou.txt file with regards to the encoding. The encoding of the file is supposedly UTF-8, but there are characters littered within that do not translate very well. I have used the codecs Python library to loop through each line and if any encoding errors are encountered, ignore them.</p><p>Running the following Python script takes ~1 hour to derive the correct hash and therefore provide us with thr flag to complete the challenge:</p><pre tabindex=0><code>import string
import hashlib
import codecs

leetspeak = {
    &#39;a&#39;: &#39;4&#39;,
    &#39;b&#39;: &#39;6&#39;,
    &#39;e&#39;: &#39;3&#39;,
    &#39;g&#39;: &#39;9&#39;,
    &#39;i&#39;: &#39;1&#39;,
    &#39;o&#39;: &#39;0&#39;,
    &#39;s&#39;: &#39;5&#39;,
    &#39;t&#39;: &#39;7&#39;,
    &#39;z&#39;: &#39;2&#39;
}

counter=0

with codecs.open(&#39;rockyou.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;, errors=&#39;ignore&#39;) as fin:
    for word in fin:
        print(counter, word)
        sample_text = word

        upper_text = sample_text[0].upper()
        upper_text += sample_text[1:]

        for s in upper_text:
            if s.lower():
                for k, v in leetspeak.items():
                    if k==s:
                        upper_text = upper_text.replace(s, v)
                        
        new_text = &#34;&#34;.join(upper_text.split())
        for first_hex_digit in string.hexdigits:
            for last_hex_digit in string.hexdigits:
                hex_text = f&#34;{first_hex_digit}{new_text}{last_hex_digit}@&#34;
                
                hash = &#39;01F3273F68195C29A1A2365BE7AD2B1AAD469A73&#39;		
                sha = hashlib.sha1(hex_text.encode(&#39;utf-8&#39;)).hexdigest()
                if sha.upper() ==  hash.upper():
                    print(f&#34;FOUND MATCH: {hex_text}&#34;)
                    with open(&#39;jumbled_flag.txt&#39;, &#39;w&#39;) as fout:
                        fout.write(f&#34;{hex_text}&#34;)
                    d = input()
                
        counter+=1
</code></pre><h1 id=forensics---repair-shop---50-pts>Forensics - Repair Shop - 50 pts<a hidden class=anchor aria-hidden=true href=#forensics---repair-shop---50-pts>#</a></h1><p>We got this file but the transmission might have corrupted it. Maybe our main suspect has tampered with the file. Help us to recover the file and the information we need!</p><p>The file provided to us for this challenge is named &lsquo;unfixed&rsquo; and does not have an extension. If we examine the file in a hex editor, we can see the first few bytes are the following:</p><p>‰PIG

���
IHDR��á��µ���¦ä��_zTXtRaw profile type exif��</p><p>PIG is not a valid magic number, but the IHDR chunk indicates this is a PNG file. We can find the PNG file structure documentation here: <a href=http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html>http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html</a></p><p>PIG should be corrected to PNG. If we run pngcheck in our Kali Linux VM, we get the following:</p><p>pngcheck unfixed
unfixed illegal (unless recently approved) unknown, public chunk IPAD
ERROR: unfixed</p><p>Using our hex editor, we can search for all instances of IPAD:</p><p><img loading=lazy src=/posts/sbtvip/images/7.PNG></p><p>There are 172 instances of invalid IPAD chunk types! If we refer back to the PNG specification, we take note of the critical chunks a PNG must contain (or not). &ldquo;A valid PNG image must contain an IHDR chunk, one or more IDAT chunks, and an IEND chunk.&rdquo;</p><p>Our unfixed file has an IHDR chunk, and&mldr; What&rsquo;s this? An IEND chunk should note the end of a PNG file, howevever, I noticed something at the end of the file in the hex editor:</p><p><img loading=lazy src=/posts/sbtvip/images/8.PNG></p><p>Is this the flag we&rsquo;re looking for? I have highlighted the interesting parts. We can see a PK text here. Consulting the magic numbers list, PK denotes the header of a ZIP file. Let&rsquo;s try and open the unfixed file as an archive!</p><p><img loading=lazy src=/posts/sbtvip/images/9.PNG></p><p>You might be asking why I&rsquo;m revealing the flag to you. Well, if we copy and paste this into a base 64 decoder, it yields hilltopMSG{keep_looking}, which definitely is not our flag. Oh well, let&rsquo;s keep looking.</p><p>Going back to our hex editor, we can see the text sEND just before the PK header. We can correct this to IEND.</p><p>We cannot have an image with a ZIP file appended to it, so we can remove all bytes after the IEND.</p><p>Okay, that&rsquo;s PNG, IHDR, IEND, so the only thing that is left is the IDAT chunks. As stated in the specification, there can be multiple of them. So if we search and replace all occurrences of IPAD to IDAT, we can open the fixed image and reveal our flag.</p><h1 id=forensics---floppy-offset---25-pts>Forensics - Floppy Offset - 25 pts<a hidden class=anchor aria-hidden=true href=#forensics---floppy-offset---25-pts>#</a></h1><p>When we seized an old laptop and floppy disks, we identified an odd one. The forensic image didn&rsquo;t match with the original. We can assume that there was some tampering. Also, the label on the floppy disk makes no sense to us. Can you recover the hidden information in the floppy disk?</p><p>There are three files included in this challenge, floppydisc.png, forensic.img, and original.img.</p><p>We&rsquo;ll focus on the png file first, as I wanted to find out what the picture meant.</p><p><img loading=lazy src=/posts/sbtvip/images/10.png></p><p>Googling for &ldquo;rscds book 52 fnc&rdquo; yields a YouTube video which I found funny. I don&rsquo;t think it has much to do with the overall flag.</p><p>If we compute a hash for both the forensic and original images, we see a difference. If we use a hex compare utility to see which bytes are different, we see the following:</p><p><img loading=lazy src=/posts/sbtvip/images/11.PNG></p><p>If we copy and paste this into a base 64 decoder, our flag is revealed.</p><h1 id=general-knowledge---twin---25-pts>General Knowledge - Twin - 25 pts<a hidden class=anchor aria-hidden=true href=#general-knowledge---twin---25-pts>#</a></h1><p>Find the only pair of identical lines.</p><p>Sounds easy? Well, you&rsquo;ve only got 88000 lines across 4400 files to compare.</p><p>The flag format is HilltopCTF{}.</p><p>Well then, I&rsquo;m sure a simple Python script should be able to loop through each line within all files and check if we have already looped through a specific line:</p><pre tabindex=0><code>import os
import base64

seen = set()
for root, dirs, files in os.walk(&#34;Twin&#34;, topdown=False):
	for name in files:
		with open(f&#34;Twin\\{name}&#34;, &#39;r&#39;) as fin:
			for line in fin:
				line_lower = line.rstrip().lower()
				if line_lower in seen:
					print(line)
					print(base64.b64decode(line))
				else:
					seen.add(line_lower)
</code></pre><p>Once it finds a duplicate line, it decodes it from base 64 to reveal something that is not a flag. Parts of the text have patterns, so maybe we need to decode it further. If we input the text into a ROT-13 decoder, our flag is revealed.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://isuquo.github.io/>My blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>