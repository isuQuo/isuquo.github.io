<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>SBTVIP CTF Challenges | My blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><meta name=generator content="Hugo 0.147.8"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=canonical href=https://isuquo.github.io/posts/sbtvip/><meta property="og:url" content="https://isuquo.github.io/posts/sbtvip/"><meta property="og:site_name" content="My blog"><meta property="og:title" content="SBTVIP CTF Challenges"><meta property="og:description" content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-29T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-29T00:00:00+00:00"><meta itemprop=name content="SBTVIP CTF Challenges"><meta itemprop=description content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"><meta itemprop=datePublished content="2020-02-29T00:00:00+00:00"><meta itemprop=dateModified content="2020-02-29T00:00:00+00:00"><meta itemprop=wordCount content="2021"><meta name=twitter:card content="summary"><meta name=twitter:title content="SBTVIP CTF Challenges"><meta name=twitter:description content="Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.
As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit https://sbtvip.ctfd.io/challenges, make an account and get going!"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">My blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">SBTVIP CTF Challenges</h1><time class="f6 mv4 dib tracked" datetime=2020-02-29T00:00:00Z>February 29, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Over the past four weeks, SecurityBlue.Team have released their very first CTF event. During the first two weeks, the CTF was only available to VIP members. The last two weeks were open to the public. As it stands, there are currently over 300 participants. During the VIP tenure, there were ~50 participants, including me.</p><p>As the CTF is still open and very much active, I will not be revealing the flags. As such, I will showcase the methods I used to retrieve these flags for my favourite challenges. If you wish to have a go, visit <a href=https://sbtvip.ctfd.io/challenges>https://sbtvip.ctfd.io/challenges</a>, make an account and get going!</p><h1 id=network-analysis---sneaky-transmission---50-pts>Network Analysis - Sneaky Transmission - 50 pts</h1><blockquote><p>Is this a DoS attack? Or could this be &mldr; a photo!?</p></blockquote><p>When downloading the attached file for this challenge, we receive a sneaky_transmission.pcapng file. Viewing this file in Wireshark yields a packet capture full of ICMP packets.</p><p>As with all packet captures, we need to know what we&rsquo;re dealing with and how the protocol works in order to ascertain what the high level goal of the capture is.</p><p><img src=images/1.PNG alt></p><p>Generally when viewing ICMP packet captures, we need to bring our attention to a few things. First, we take note of the length of packet. They are all a length of 98 bytes. If it were anomalous, we could deem it as suspicious. Speaking of anomalous, we turn our attention to the TTL (time to live). Notice anything? All request packets have a different TTL set. This could be an indication of ICMP data exfiltration, or ICMP tunnelling.</p><p>We can begin to inspect the payload data of the request packets to see if we can make out any data being sent over the network. We can use the filter &ldquo;icmp.type == 8&rdquo; to only display request packets. When scrolling through each packet, we see part of the data section contains the same bytes:</p><p><img src=images/2.PNG alt></p><p>As we scroll through each packet, we note the changing bytes. For the first few packets, it doesn&rsquo;t look like much, until we get further down to frame no. 13. With a sharp eye, you might notice the following sequence of bytes:</p><p><img src=images/3.PNG alt></p><p><img src=images/4.PNG alt></p><p><img src=images/5.PNG alt></p><p><img src=images/6.PNG alt></p><p>What do the highlighted bytes spell? JFIF! (without the exclamation mark). JFIF is the magic number for a JPEG image. The description of the challenge also confirms for us that the data being sent in the payload is a JPEG image. Next we need to extract the data.</p><p>At the time of my attempt at this challenge, I missed one important detail about the packets. The above highlighted bytes correpsond to the TTL value. Meaning the JPEG image was hidden in the TTL field, which would&rsquo;ve made for easier extraction.</p><p>Admittedly, I did not extract the data using Wireshark nor using normal means via scripting. I used the Scapy Python module to exract the data but since I could not find a sure-fire method of extracting the exact bytes I wanted, so instead I implemented a method called Monkey Patching.</p><p>As mentioned, we will be using the Scapy Python module, a very popular packet manipulation tool.</p><p>Our goal is to extract each byte at a specific offset of the payload data.</p><p>As you can see with the above, the only data from the payload we can print is the fixed data. It does not change.</p><p>Using the hexdump method Scapy provides, we can print out a hexdump of the payload data, exactly how it is displayed in Wireshark. The problem with this output is that it&rsquo;s type is NoneType. It doesn&rsquo;t output as a string. If this were the case, I could extract the specific bytes I needed using string slicing.</p><p>The only fix I managed for this was to edit the hexdump method provided by the Scapy library.</p><p>Located in the utls.py file, we can copy and paste the hexdump method into our own Python script:</p><pre tabindex=0><code>from scapy.all import *
 
pkts = rdpcap(&#34;sneaky_transmission.pcapng&#34;)

def hexdump(x, dump=False):
    &#34;&#34;&#34;Build a tcpdump like hexadecimal view

    :param x: a Packet
    :param dump: define if the result must be printed or returned in a variable
    :returns: a String only when dump=True
    &#34;&#34;&#34;
    # EDIT: create an empty list to append our bytes to
    sneaky_bytes = []
    s = &#34;&#34;
    x = bytes_encode(x)
    x_len = len(x)
    i = 0
    while i &lt; x_len:
        s += &#34;%04x  &#34; % i
        for j in range(16):
            if i + j &lt; x_len:
                s += &#34;%02X &#34; % orb(x[i + j])
                # EDIT: we only want to extract specific bytes
                if i == 0 and j == 8:
                    # EDIT: append those bytes to our list
                    sneaky_bytes.append(orb(x[i + j]))
            else:
                s += &#34;   &#34;
        s += &#34; %s\n&#34; % sane_color(x[i:i + 16])
        i += 16
    # remove trailing \n
    s = s[:-1] if s.endswith(&#34;\n&#34;) else s
    if dump:
        return s
    else:
        # EDIT: create a new jpeg file and append our bytes to the file
        with open(&#39;sneaky.jpg&#39;, &#39;ab&#39;) as fout:
            fout.write(bytearray(sneaky_bytes))
        #print(s)
</code></pre><p>I have created comments with &ldquo;EDIT: " prepended to them to indicate which lines I have added.</p><p>If we execute this script, the specific bytes are extracted and appended to a JPEG file. If we open the JPG file after execution, our flag is revealed!</p><h1 id=password-cracking---jumbled---50-pts>Password Cracking - Jumbled - 50 pts</h1><blockquote></blockquote><pre><code>I've found a hash of the password for the domain controller.
01F3273F68195C29A1A2365BE7AD2B1AAD469A73
I've also found this note:
Company Password Policy:
1 hex digit prepended
1 hex digit appended
First letter capitalised
An '@' appended to the end
Leetspeak (a =&gt; 4, b =&gt; 6, e =&gt; 3, g =&gt; 9, i =&gt; 1, o =&gt; 0, s =&gt; 5, t =&gt; 7, z =&gt; 2) [Capital letters not included]
Example: rockme =&gt; fR0ckm37@

Can you crack the hash using rockyou.txt?

The flag is HilltopCTF{password}
</code></pre><p>This challenge was meant to be cracked using John The Ripper, however, I did not think to use it and instead began writing a Python script to brute force the hash.</p><p>In order to compute hashes and compare it to the one provided in the description of the challenge, we first need to determine what type of hash it is. Using Hash Analyzer, we can see it is a SHA1 hash.</p><p>Overall, we need to derive a password in the format of &lt;hex_digit> &lt;first_letter_capitalized> &lt;lowercase_leetspeak> &lt;hex_digit> &lt;@_sign>.</p><p>We do this by first looping through the rockyou.txt file (HUGE file by the way, 14 million lines long), capitilize the first letter, substitute applicable letters for their leet counterparts (remember Python strings are immutable), prepend and append a hex digit to the output, and append an @ sign to the end of the final string.</p><p>Lastly, compute the hash of the final string and compare it with the one provided in the description of the challenge.</p><p>I ran into an error when looping through the rockyou.txt file with regards to the encoding. The encoding of the file is supposedly UTF-8, but there are characters littered within that do not translate very well. I have used the codecs Python library to loop through each line and if any encoding errors are encountered, ignore them.</p><p>Running the following Python script takes ~1 hour to derive the correct hash and therefore provide us with thr flag to complete the challenge:</p><pre tabindex=0><code>import string
import hashlib
import codecs

leetspeak = {
    &#39;a&#39;: &#39;4&#39;,
    &#39;b&#39;: &#39;6&#39;,
    &#39;e&#39;: &#39;3&#39;,
    &#39;g&#39;: &#39;9&#39;,
    &#39;i&#39;: &#39;1&#39;,
    &#39;o&#39;: &#39;0&#39;,
    &#39;s&#39;: &#39;5&#39;,
    &#39;t&#39;: &#39;7&#39;,
    &#39;z&#39;: &#39;2&#39;
}

counter=0

with codecs.open(&#39;rockyou.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;, errors=&#39;ignore&#39;) as fin:
    for word in fin:
        print(counter, word)
        sample_text = word

        upper_text = sample_text[0].upper()
        upper_text += sample_text[1:]

        for s in upper_text:
            if s.lower():
                for k, v in leetspeak.items():
                    if k==s:
                        upper_text = upper_text.replace(s, v)
                        
        new_text = &#34;&#34;.join(upper_text.split())
        for first_hex_digit in string.hexdigits:
            for last_hex_digit in string.hexdigits:
                hex_text = f&#34;{first_hex_digit}{new_text}{last_hex_digit}@&#34;
                
                hash = &#39;01F3273F68195C29A1A2365BE7AD2B1AAD469A73&#39;		
                sha = hashlib.sha1(hex_text.encode(&#39;utf-8&#39;)).hexdigest()
                if sha.upper() ==  hash.upper():
                    print(f&#34;FOUND MATCH: {hex_text}&#34;)
                    with open(&#39;jumbled_flag.txt&#39;, &#39;w&#39;) as fout:
                        fout.write(f&#34;{hex_text}&#34;)
                    d = input()
                
        counter+=1
</code></pre><h1 id=forensics---repair-shop---50-pts>Forensics - Repair Shop - 50 pts</h1><p>We got this file but the transmission might have corrupted it. Maybe our main suspect has tampered with the file. Help us to recover the file and the information we need!</p><p>The file provided to us for this challenge is named &lsquo;unfixed&rsquo; and does not have an extension. If we examine the file in a hex editor, we can see the first few bytes are the following:</p><p>‰PIG

���
IHDR��á��µ���¦ä��_zTXtRaw profile type exif��</p><p>PIG is not a valid magic number, but the IHDR chunk indicates this is a PNG file. We can find the PNG file structure documentation here: <a href=http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html>http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html</a></p><p>PIG should be corrected to PNG. If we run pngcheck in our Kali Linux VM, we get the following:</p><p>pngcheck unfixed
unfixed illegal (unless recently approved) unknown, public chunk IPAD
ERROR: unfixed</p><p>Using our hex editor, we can search for all instances of IPAD:</p><p><img src=images/7.PNG alt></p><p>There are 172 instances of invalid IPAD chunk types! If we refer back to the PNG specification, we take note of the critical chunks a PNG must contain (or not). &ldquo;A valid PNG image must contain an IHDR chunk, one or more IDAT chunks, and an IEND chunk.&rdquo;</p><p>Our unfixed file has an IHDR chunk, and&mldr; What&rsquo;s this? An IEND chunk should note the end of a PNG file, howevever, I noticed something at the end of the file in the hex editor:</p><p><img src=images/8.PNG alt></p><p>Is this the flag we&rsquo;re looking for? I have highlighted the interesting parts. We can see a PK text here. Consulting the magic numbers list, PK denotes the header of a ZIP file. Let&rsquo;s try and open the unfixed file as an archive!</p><p><img src=images/9.PNG alt></p><p>You might be asking why I&rsquo;m revealing the flag to you. Well, if we copy and paste this into a base 64 decoder, it yields hilltopMSG{keep_looking}, which definitely is not our flag. Oh well, let&rsquo;s keep looking.</p><p>Going back to our hex editor, we can see the text sEND just before the PK header. We can correct this to IEND.</p><p>We cannot have an image with a ZIP file appended to it, so we can remove all bytes after the IEND.</p><p>Okay, that&rsquo;s PNG, IHDR, IEND, so the only thing that is left is the IDAT chunks. As stated in the specification, there can be multiple of them. So if we search and replace all occurrences of IPAD to IDAT, we can open the fixed image and reveal our flag.</p><h1 id=forensics---floppy-offset---25-pts>Forensics - Floppy Offset - 25 pts</h1><p>When we seized an old laptop and floppy disks, we identified an odd one. The forensic image didn&rsquo;t match with the original. We can assume that there was some tampering. Also, the label on the floppy disk makes no sense to us. Can you recover the hidden information in the floppy disk?</p><p>There are three files included in this challenge, floppydisc.png, forensic.img, and original.img.</p><p>We&rsquo;ll focus on the png file first, as I wanted to find out what the picture meant.</p><p><img src=images/10.PNG alt></p><p>Googling for &ldquo;rscds book 52 fnc&rdquo; yields a YouTube video which I found funny. I don&rsquo;t think it has much to do with the overall flag.</p><p>If we compute a hash for both the forensic and original images, we see a difference. If we use a hex compare utility to see which bytes are different, we see the following:</p><p><img src=images/11.PNG alt></p><p>If we copy and paste this into a base 64 decoder, our flag is revealed.</p><h1 id=general-knowledge---twin---25-pts>General Knowledge - Twin - 25 pts</h1><p>Find the only pair of identical lines.</p><p>Sounds easy? Well, you&rsquo;ve only got 88000 lines across 4400 files to compare.</p><p>The flag format is HilltopCTF{}.</p><p>Well then, I&rsquo;m sure a simple Python script should be able to loop through each line within all files and check if we have already looped through a specific line:</p><pre tabindex=0><code>import os
import base64

seen = set()
for root, dirs, files in os.walk(&#34;Twin&#34;, topdown=False):
	for name in files:
		with open(f&#34;Twin\\{name}&#34;, &#39;r&#39;) as fin:
			for line in fin:
				line_lower = line.rstrip().lower()
				if line_lower in seen:
					print(line)
					print(base64.b64decode(line))
				else:
					seen.add(line_lower)
</code></pre><p>Once it finds a duplicate line, it decodes it from base 64 to reveal something that is not a flag. Parts of the text have patterns, so maybe we need to decode it further. If we input the text into a ROT-13 decoder, our flag is revealed.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://isuquo.github.io/>&copy; My blog 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>